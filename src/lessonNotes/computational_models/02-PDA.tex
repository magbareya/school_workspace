\documentclass[14pt]{extarticle}
\input{../../../scripts/tex_preamble.tex}


\title{أوتومات الراصة واللغات خالية السياق}

\begin{document}

\maketitle

\renewcommand{\contentsname}{جدول المحتويات}
\tableofcontents
\clearpage

\section{مقدمة في النظرية الحسابية والراصة}

\subsection{لماذا نحتاج إلى نموذج جديد؟}

لقد درسنا سابقاً \textbf{الأوتومات النهائي} (\textenglish{Finite Automata - FA})، ورأينا قدرته على التعرف على \textbf{اللغات النظامية} (\textenglish{Regular Languages}). الأوتومات النهائي يتميز بالبساطة والكفاءة، ولكنه يعاني من قيد جوهري: \textbf{الذاكرة المحدودة}.

الأوتومات النهائي يمتلك عدداً نهائياً من الحالات، مما يعني أنه لا يستطيع "تذكر" أو "عدّ" كميات غير محدودة من المعلومات. على سبيل المثال، إذا أردنا فحص ما إذا كان عدد الأقواس المفتوحة يساوي عدد الأقواس المغلقة في برنامج طويل جداً، فإن الأوتومات النهائي سيفشل لأنه سيحتاج إلى عدد لا نهائي من الحالات لتتبع كل احتمال ممكن للعدد.

\subsubsection{حدود الأوتومات النهائي}
لنأخذ اللغة الشهيرة:
$$ L = \{ a^n b^n \mid n \ge 0 \} $$
هذه اللغة تتكون من تتابعات تبدأ بعدد معين من الحرف $a$، متبوعاً بنفس العدد تماماً من الحرف $b$.
\begin{itemize}
    \item \textbf{التحدي:} لمقارنة عدد $b$ بعدد $a$، يجب على الآلة أن "تتذكر" كم $a$ قرأت سابقاً.
     \item \textbf{المشكلة:} بما أن $n$ يمكن أن يكون أي عدد صحيح موجب (بلا سقف)، فإننا نحتاج نظرياً إلى ذاكرة لا نهائية.
     \item \textbf{النتيجة:} هذه اللغة ليست لغة نظامية (\textenglish{Non-Regular Language}) ولا يمكن لأوتومات نهائي التعرف عليها.
 \end{itemize}

هنا تبرز الحاجة إلى نموذج أقوى، وهو \textbf{أوتومات الراصة} (\textenglish{Pushdown Automata - PDA}).

\subsection{مفهوم الراصة (\textenglish{Stack})}

الراصة هي مبنى معطيات تعمل وفق مبدأ \textbf{"الداخل آخراً، الخارج أولاً"} (\textenglish{LIFO - Last In First Out}). يمكن تخيل الراصة ككومة من الصحون:
\begin{enumerate}
    \item \textbf{الإضافة:} يمكنك وضع صحن جديد فقط على قمة الكومة.
    \item \textbf{الإزالة:} يمكنك سحب صحن فقط من قمة الكومة.
    \item \textbf{الوصول:} لا يمكنك رؤية أو سحب صحن من المنتصف أو القاع دون إزالة ما فوقه أولاً.
\end{enumerate}

في علم الحاسوب ونظرية الأوتومات، تمنح الراصة الأوتومات ذاكرة \textbf{غير محدودة} من حيث السعة، ولكنها \textbf{مقيدة} من حيث طريقة الوصول.

\subsubsection{العمليات الأساسية على الراصة}

ستتعلمون (أو ربما تعلمتم) موضوع الراصة في قسم مباني المعطيات في البرمجة. ما يهمّنا هنا هو عمليّتان من عمليّات الرّاصّة:
\begin{description}
    \item[\textenglish{Push} (إدخال/دفع):]
    إضافة رمز جديد إلى أعلى الراصة. الرمز الجديد يصبح هو \textenglish{Top of Stack}.

    \item[\textenglish{Pop} (إخراج/سحب):]
    إزالة الرمز الموجود حالياً في قمة الراصة. الرمز الذي كان تحته يصبح هو القمة الجديدة.

\end{description}

\subsubsection{خصائص هامة للراصة}
\begin{itemize}
    \item \textbf{الحجم:} لا نهائي نظرياً. لا يمكن للراصة أن "تمتلئ" في هذا النموذج النظري، ولكنها يمكن أن تفرغ.
    \item \textbf{رمز القاع:} عادة ما نرمز له بـ $\perp$. وجود هذا الرمز يعني أن الراصة فارغة تمامًا ولا يمكن سحب شيء منها.
    \item \textbf{الخطأ} محاولة تنفيذ عملية \textenglish{Pop} على راصة فارغة تؤدي إلى توقف الأوتومات (أو تعليق العمل)، مما يعني رفض الكلمة المدخلة.
\end{itemize}

\clearpage

\section{التعريف الرسمي لأوتومات الراصة}

\subsection{مكوّنات الأوتومات السّتّة}

يُعرّف أوتومات الراصة (\textenglish{PDA}) رياضياً بأنه سداسية:
$$ M = (Q, \Sigma, \Gamma, \delta, q_0, F) $$

حيث:

\begin{enumerate}
    \item \textbf{$Q$ حالات الأوتومات:}
    مجموعة نهائية من الحالات. مثال: $Q = \{q_0, q_1, q_2\}$.

    \item \textbf{$\Sigma$ أبجدية الإدخال:}
    مجموعة الرموز التي تتكون منها الكلمات المدخلة. مثال: $\Sigma = \{a, b\}$.

    \item \textbf{$\Gamma$ أبجدية الرّاصّة:}
    مجموعة الرموز المسموح تخزينها داخل الراصة. قد تكون هذه المجموعة مساوية لـ $\Sigma$ أو مختلفة عنها. تحتوي عادةً على رموز مساعدة. مثال: $\Gamma = \{A, B,S\}$. \\
    هذه المجموعة يعرّفها من يبني الأوتومات (أي هي ليست معطاة مثل $\Sigma$). \\
    عادة نستعمل أحرفًا كبيرة لأبجدية الرّاصة، وأحرفًا صغير لأبجدية الإدخال.

    \item \textbf{$q_0$ حالة البداية:}
    حيث يبدأ الأوتومات عمله. ($q_0 \in Q$).

    \item \textbf{$F$ الحالات القابلة:}
    مجموعة حالات القبول. ($F \subseteq Q$).

    \item \textbf{$\delta$ دالة الانتقالات:}
    دالة الانتقال، وهي التي تحدد منطق عمل الأوتومات.
\end{enumerate}
نلاحظ أن تعريف أوتومات الرّاصة يشبه إلى حد كبير تعريف الأوتومات النّهائي.
\subsection{شرح دالة الانتقال $\delta$}

تختلف دالة الانتقال في أوتومات الراصة عن نظيرتها في الأوتومات النهائي. فهي تعتمد على ثلاثة عوامل (مدخلات) وتنتج مخرجين:
$$ \delta: (Q \times \Sigma \times \Gamma) \to (Q \times \Gamma^*) $$

\textbf{تفسير المدخلات (الجانب الأيسر):}
\begin{itemize}
    \item $Q$: الحالة الحالية للأوتومات.
    \item $\Sigma$: الرمز الذي يقرؤه الرأس من شريط الإدخال.
    \item $\Gamma$: الرمز الموجود في قمة الراصة. يجب تحديد ما هو الرمز الموجود في الأعلى لتنفيذ الانتقال.
\end{itemize}

\textbf{تفسير المخرجات (الجانب الأيمن):}
\begin{itemize}
    \item $Q$: الحالة الجديدة التي سينتقل إليها الأوتومات.
    \item $\Gamma^*$: سلسلة من رموز الراصة (قد تكون فارغة $\epsilon$، رمزاً واحداً، أو عدة رموز) ستحل محل الرمز الذي تم سحبه من القمة.
\end{itemize}

\textbf{مثلًا:} الانتقال: $\delta(q, a, X) = (p, XY)$ معناه: إذا كان الأوتومات في الحالة $q$ وقرأ الحرف $a$ من المدخل وكان الرمز في أعلى الراصة هو $X$، عندها ينتقل الأوتومات إلى الحالة $p$ ونكتب في أعلى الراصّة $XY$ بدل ال $X$ (أي عمليا نضيف $Y$ إلى أعلى الراصة).

\subsubsection{أنواع عمليات الراصة عبر دالة الانتقال}

لنفترض الانتقال: $\delta(q, a, X) = (p, \gamma)$
حيث $X$ هو الرمز في القمة، و $\gamma$ هي السلسلة التي سنكتبها. \\
عندها يوجد عدّة عمليّات يمكننا فعلها:

\begin{enumerate}
    \item \textbf{\textenglish{Pop} (الحذف):}
    إذا كانت $\gamma = \epsilon$.
    المعنى: تم إزالة $X$ ولم نضع شيئاً مكانه. طول الراصة نقص بمقدار 1.

    \item \textbf{\textenglish{Replace} (الاستبدال / تغيير القمة):}
    إذا كانت $\gamma = Y$ (رمز واحد مختلف).
    المعنى: تم إزالة $X$ ووضع $Y$ مكانه. طول الراصة لم يتغير.

    \item \textbf{\textenglish{Push} (الإضافة):}
    إذا كانت $\gamma = YX$ (أو $YZ$).
    المعنى: تم إزالة $X$، ثم وضعنا $X$ مرة أخرى وفوقه $Y$. عملياً، $X$ بقي مكانه وأضفنا $Y$.
    يمكن أيضاً دفع أكثر من رمز، مثل $\gamma = ABC$. في هذه الحالة، $C$ سيكون في القمة، تحته $B$، وتحته $A$.

    \item \textbf{\textenglish{No Operation} (لا تغيير):}
    إذا كانت $\gamma = X$.
    المعنى: قرأنا $X$ ووضعناه كما هو.
\end{enumerate}

عادةً، عند رسم أوتومات راصّة، نكتب على الانتقال (السهم بين حالتين): رمز المدخل، رمز أعلى الراصة ثم \/ ثم العملية التي نريد فعلها في الراصة عند الانتقال. \\
مثلًا:
\begin{center}
    \includegraphics[width=0.3\paperwidth,keepaspectratio]{../../../images/PDAs/delta_example.png}%
\end{center}
في هذا المثال كتبنا: $a,A / \text{push } A$ فهذا يعني أن الأوتومات إذا كان في الحالة $q_0$ وقرأ الحرف $a$ من المدخل، وأعلى الرّاصّة كان $X$، فإنّه ينتقل إلى الحالة $q_1$ ويدخل $A$ إلى أعلى الراصة. \\
بنفس المنطق يمكننا كتابة \textenglish{pop A} أو \textenglish{no change} للتعبير عن إخراج حرف الـ $A$ أو عدم تغيير الراصة.

\subsection{شرط قبول الكلمة في الأوتومات}
حتى نعتبر أنّ كلمة ما $w$ مقبولة، يجب أن يتحقق في نهاية تنفيذها شرطان:
\begin{enumerate}
\item تمكن الأوتومات من قراءتها بالكامل والوصول إلى حالة تنتمي للمجموعة $F$.
\item وإذا كانت الرّاصة فارغة تمامًا في النّهاية.
\end{enumerate}

\textbf{ملاحظة:} عمليًّا، يمكننا اشتراط واحد من الشرطين أعلاه فقط، ويكون الأمر مكافئًا لاشتراط الشرطين معًا. لكننا في الأسئلة سنعتمد أنّه يجب أن يتحقق كلا الشّرطين.

\clearpage

\section{أمثلة وتطبيقات تفصيلية}

في هذا الفصل، سنبني أوتوماتات لعدة لغات شهيرة، مع شرح المنطق وجداول الانتقال.

\subsection{مثال: اللغة النموذجية $L = \{ a^n b^n \mid n \ge 1 \}$}

هذه هي اللغة الكلاسيكية لشرح \textenglish{PDA}. الشرط هو تساوي عدد الـ $a$ والـ $b$ وترتيبهم.

\subsubsection{فكرة الحل}
نستخدم الرّاصّة لعدّ مرات ظهور الـ $a$، عن طريق إدخال رمز خاص مقابل كل $a$ نقرؤه، ثم عند قراءة الـ $b$ نخرج من الراصّة رمزًا مقابل كل $b$ نقرؤه، يجب أن ننتهي من قراءة الـ $b$ بالضبط عندما تصبح الرّاصّة فارغة.
\begin{enumerate}
    \item \textbf{البداية:} الراصة فارغة.
    \item \textbf{قراءة أوّل حرف $a$:} عند قراءة أوّل حرف $a$ نُدخل إلى الرّاصة رمزًا مميّزًا، عادة $S$. سنحتاج إلى هذا الرّمز لمعرفة أنّ الرّاصة بعده فارغة.
    \item \textbf{قراءة $a$:} لكل حرف $a$ يظهر في المدخل، نقوم بعملية إدخال (\textenglish{Push}) للرمز $A$ في الراصة. هذا يسمح لنا بـ "عدّ" حروف $a$.
    \item \textbf{قراءة $b$:} بمجرد ظهور أول حرف $b$، نغير السلوك. لكل حرف $b$ نقرؤه، نقوم بعملية إخراج (\textenglish{Pop}) لرمز $A$ من الراصة. هذا يمثل "المطابقة" أو "الحذف المقابل".
    \item \textbf{قراءة آخر $b$:} عندما يصبح أعلى الرّاصّة الرمز $S$، فهذا يعني أنّه يجب أن يكون حرف الـ $b$ القادم هو الحرف الأخير في الكلمة، كي يكون عدد الـ $b$ مساويًا لعدد الـ $a$. \\
     لذلك إذا قرأنا الرمز $b$ وكان أعلى الراصة هو الرمز $S$ فإنّنا ننتقل إلى حالة قابلة ونخرج الـ $S$ من الراصة لتصبح فارغة.
    \item \textbf{النهاية:}
    \begin{itemize}
        \item إذا انتهت الكلمة والراصة أصبحت فارغة (وصلنا لـ $S$ وسحبناه)، فالكلمة مقبولة (العدد متساوٍ).
        \item إذا انتهت الكلمة ولا يزال في الراصة رموز $A$، فنرفض الكلمة (عدد $a$ أكبر).
        \item إذا جاء حرف $b$ والراصة فارغة من $A$، فنرفض الكلمة (عدد $b$ أكبر).
        \item إذا جاء حرف $a$ بعد حرف $b$، فنرفض الكلمة(الترتيب خطأ).
    \end{itemize}
\end{enumerate}

\subsubsection{التصميم الرسمي}

\begin{center}
\includegraphics[width=\textwidth]{../../../images/PDAs/an_bn.png}
\end{center}

% الأوتومات $M = (\{q_0, q_1, q_2, q_3\}, \{a, b\}, \{A, S\}, \delta, q_0, \{q_3\})$ \\


% \textbf{جدول الانتقالات المفصل:}
% \begin{center}
% \begin{tabular}{|c|c|c|c|c|c|}
% \hline
% \textbf{\#} & \textbf{الحالة} & \textbf{المدخل} & \textbf{الراصة} & \textbf{الناتج $(q_{new}, \gamma)$} & \textbf{الشرح} \\
% \hline
% 1 & $q_0$ & $a$ & $\perp$ & $(q_1, S)$ & قراءة أول $a$، دفع $S$، انتقال لحالة التجميع $q_1$. \\
% \hline
% 2 & $q_1$ & $a$ & $A$ & $(q_1, A)$ & قراءة $a$ تالية، دفع $A$ إضافي فوق الموجود. \\
% \hline
% 3 & $q_1$ & $b$ & $A$ & $(q_2, \epsilon)$ & قراءة أول $b$، سحب $A$، انتقال لحالة المطابقة $q_2$. \\
% \hline
% 4 & $q_2$ & $b$ & $A$ & $(q_2, \epsilon)$ & قراءة $b$ تالية، سحب $A$ مقابل لها. \\
% \hline
% 5 & $q_2$ & $\epsilon$ & $S$ & $(q_3, S)$ & انتهاء الدخل، الراصة نظيفة، انتقال للقبول. \\
% \hline
% \end{tabular}
% \end{center}

\subsubsection{تتبع التنفيذ (\textenglish{Trace}) للكلمة $aaabbb$}
\begin{enumerate}
    \item $(q_0, aaabbb, \perp) \vdash (q_1, aabbb, S)$
    \item $(q_1, aabbb, S) \vdash (q_1, abbb, AS)$
    \item $(q_1, abbb, AS) \vdash (q_1, bbb, AAS)$
    \item $(q_1, bbb, AAS) \vdash (q_2, bb, AS)$
    \item $(q_2, bb, AS) \vdash (q_2, b, S)$
    \item $(q_2, b, S) \vdash (q_3, \epsilon, \perp)$
\end{enumerate}

في نهاية التنفيذ كانت الرّاصّة فارغة، وانتهينا من قراءة الكلمة في الحالة $q_3$ وهي حالة قابلة. لذلك الكلمة مقبولة.

\clearpage

\subsection{مثال: اللغة $L = \{ a^n b^k c^{n+k} \mid n,k \ge 1 \}$}
في هذه الحالة علينا التأكّد أنّ عدد الـ $c$ في الكلمة مساوٍ لمجموع عدد الـ $a$ والـ $b$. \\
نتّبع فكرة شبيهة بالفكرة السابقة، لكن الآن سوف ندفع إلى داخل الراصة إذا قرأنا $a$ أو $b$، ونسحب منها إذا قرأنا $c$.

\begin{center}
\includegraphics[width=\textwidth]{../../../images/PDAs/an_bk_cnk_ge1.png}
\end{center}

قد تظنّ للوهلة الأولى أنّنا عندما نقرأ $b$ فإن علينا أن ندفع رمزًا مختلفًا إلى الرّاصة (مثلًا $B$)، لكن في الواقع لا حاجة لذلك، لأنّه لا فرق عندنا بين الـ $a$ والـ $b$ عندما نعدّ، مقابل كل واحد منهما يجب أن نرى $c$ واحد.

\subsubsection{تعديل للمثال السابق: اللغة $L = \{ a^n b^k c^{n+k} \mid n,k \ge 0 \}$}
انتبه أنّه في هذه اللغة، الـ $n$ والـ $k$ يمكن أن يكونا صفرًا، أي أنّ الكلمة الفارغة $\varepsilon$ هو كلمة مقبولة في اللغة. \\
كما أنّه علينا الاهتمام بالانتقالات عندما لا يظهر $a$ أو لا يظهر $b$ في الكلمة.

\begin{center}
\includegraphics[width=\textwidth]{../../../images/PDAs/an_bk_cnk_ge0.png}
\end{center}
\clearpage

\subsection{مثال: اللغة $L = \{ a^n b^k c^k \mid n,k \ge 0 \}$}
نلاحظ أنّه في هذه اللغة لا حاجة لعدّ مرات ظهور الـ $a$، فقط علينا مقارنة عدد الـ $b$ والـ $c$ والتأكد أنّهما متساويان. \\
لذلك، طالما أنّنا نقرأ $a$ سنبقى في الحالة الابتدائية، بدون تغيير الرّاصّة، فقط عند بداية قراءة الـ $b$ سننتقل إلى الحالة التالية ونبدأ بعدّ الـ $b$ ونكمل بعدها كما في الأمثلة السابقة. \\
ننتبه أيضًا أنّ $\epsilon$ موجود في هذه اللغة، لذلك، الحالة الابتدائية ستكون حالة قابلة.
\begin{center}
\includegraphics[width=0.7\textwidth]{../../../images/PDAs/an_bm_ck_m_equals_k.png}
\end{center}
%\clearpage

\subsection{مثال: اللغة $L = \{ a^n b^{2n} \mid n \ge 1 \}$}
هنا العلاقة ليست مساواة ($1:1$) بل علاقة ضعف ($1:2$). لكل $a$ يوجد اثنان $b$.

\subsubsection{الحل}
بما أننا لا نستطيع إدخال "نصف رمز" للراصة، سنقوم بحيلة بسيطة:
\textbf{لكل حرف $a$ ندخل رمزين إلى الراصة.}

\begin{enumerate}
    \item اقرأ $a$ $\leftarrow$ \textenglish{Push AA}.
    \item اقرأ $b$ $\leftarrow$ \textenglish{Pop A}.
\end{enumerate}
بهذه الطريقة، إذا كان لدينا 3 $a's$، سيكون في الراصة 6 $A's$. سنحتاج بالضبط 6 $b's$ لتفريغها.


\begin{center}
\includegraphics[width=\textwidth]{../../../images/PDAs/an_b2n.png}
\end{center}
\clearpage

\subsection{مثال: اللغة $L = \{ a^{2n} b^n \mid n \ge 1 \}$}
كما في المثال السابق، العلاقة هنا ليست مساواة ($1:1$) في هذه الحالة هي علاقة نصف ($2:1$). لكل اثنين $a$ يوجد $b$ واحد. \\
\textbf{تذكّر} أنّه لا يمكننا إخراج رمزين من الرّاصة في انتقال واحد. لذلك هنا سنحتاج إلى "حيلة" جديدة.

\subsubsection{الحل}
بما أننا لا نستطيع إخراج رمزين من الرّاصة في انتقال واحد، فإنّنا سنُدخل إلى الرّاصة رموزًا مساويًا لنصف عدد الـ $a$. لنفعل ذلك: إذا قرأنا $a$ فإنّنا مرّة نُدخل إلى الرّاصة رمزًا والمرة التالية لا ندخل، وهكذا...
\begin{enumerate}
    \item إذا اقرأنا $a$ في مكان فردي: $\leftarrow$ \textenglish{Push A}.
    \item إذا اقرأنا $a$ في مكان زوجي، عندها لا نغير الراصة.
    \item إذا قرأنا $b$ $\leftarrow$ \textenglish{Pop A}.
\end{enumerate}
بهذه الطريقة، إذا كان لدينا 6 $a$'s، سيكون في الراصة 3 $A$'s. سنحتاج بالضبط 3 $b$'s لتفريغها.


\begin{center}
\includegraphics[width=\textwidth]{../../../images/PDAs/a2n_bn.png}
\end{center}

\clearpage

\subsection{مثال: الأقواس المتوازنة}
اللغة تتكون من سلاسل أقواس صحيحة رياضياً. \\
مثال مقبول: $(()())()$ \\
مثال مرفوض: $(()$ أو $())($

الراصة مثالية لهذا النوع من المشاكل. كل قوس مفتوح `(` يمثل "دَيناً" يجب سداده بقوس مغلق `)`.
\begin{itemize}
    \item عند رؤية `(`: ادفع $X$
    \item عند رؤية `)`: اسحب $X$
    \item القبول: الراصة فارغة في النهاية.
    \item الخطأ: محاولة سحب من راصة فارغة (يعني قوس إغلاق بدون فتح)، أو بقاء رموز في الراصة في النهاية (يعني أقواس لم تُغلق).
\end{itemize}

\begin{center}
\includegraphics[width=0.5\textwidth]{../../../images/PDAs/balanced_parentheses.png}
\end{center}


% \subsubsection{نضيف تعقيدًا للسؤال (مثال لاستعمال أكثر من حرف في أبجدية الراصة)}
% ماذا لو كانت اللغة تحتوي أنواعاً مختلفة من الأقواس؟ مثلًا ثلاثة أنواع: $[ \{ ( ) \} ]$.
% أمثلة لأقواس مقبولة: $(\{\}[])$ و $\{\} ([()])$ \\
% أمثلة لأقواس غير مقبولة: $(\{)\}$ و $( \}$. \\
% في هذه الحالة، علينا التأكد من أن القوس المغلق يطابق \textbf{آخر} قوس مفتوح تم إدخاله (مبدأ \textenglish{LIFO}). \\
% في هذه الحالة علينا التمييز بين أنواع الأقواس المفتوحة التي قرأناها، ولنفعل ذلك، نعطي كلّ قوس منها رمزًا مختلفًا.
% \begin{itemize}
%     \item عند قراءة القوس $($ ندفع إلى الراصة الرمز $A$ مثلا.
%     \item عند قراءة القوس $[$ ندفع إلى الراصة الرمز $B$ مثلا.
%     \item عند قراءة القوس $\{$ ندفع إلى الراصة الرمز $C$ مثلا.
%     \item عند رؤية $)$, يجب أن يكون أعلى الراصة هو $A$.
%     \item عند رؤية $[$, يجب أن يكون أعلى الراصة هو $B$.
%     \item عند رؤية $\{$, يجب أن يكون أعلى الراصة هو $C$.
% \end{itemize}

% \clearpage

\subsection{مثال: الكلمة ومقلوبها $L = \{ w \cdot c \cdot R(w) | w \in \{a,b\}^+\}$}
هذه اللغة مكوّنة من الكلمات من $\{a,b\}^+$ يظهر بعدها الرمز $c$ ثم مقلوب الكلمة التي ظهرت قبل الرمز $c$. \\
في هذه الحالة سنضيف إلى الراصة الحرف $A$ في كل مرة نقرأ الحرف $a$، ونضيف الحرف $B$ في كل مرة نقرأ الحرف $b$، وعندما نرى الحرف $c$ نغير تصرف الأوتومات ليخرج الحرف الذي يقرأه من الراصة.

\begin{center}
\includegraphics[width=\textwidth]{../../../images/PDAs/wcRw_w_in_abplus.png}
\end{center}
\clearpage

\subsection{أمثلة على لغات تشترط على عدد الـ $a$ وعدد الـ $b$ بدون ترتيب}

\subsubsection{لكل بادئة عدد الـ $a$ ليس أصغر من عدد الـ $b$}
\label{sssection:prefix}
للتذكير: بادئة $p$ لكلمة $w$ هي سلسلة يمكن الحصول عليها عن طريق حذف رموز من نهاية $w$ بشكل متتالٍ. \\
عدد الرموز المحذوفة يمكن أن يكون أيّ عدد بين $0-|w|$، لذلك لكل كلمة $w$: $\epsilon$ و $w$  كلاهما بادئتان للكلمة $w$ . \\
مثلًا: بالنسبة للكلمة $w=abaa$، بادئاتها هي: $\epsilon, a, ab, aba, abaa$. \\
بشكل رسمي (رياضي) نعرف البادئات للكلمة $w$  بأنّه كل السلاسل $u \in \Sigma^*$ بحيث يوجد $v \in \Sigma^*$ يحقّق: $u\cdot v = w$.

اللغة المطلوبة في هذه الحالة هي كل الكلمات التي تحقق أنّه في كلّ بادئة لها: عدد الـ $a$ ليس أصغر من عدد الـ $b$. \\
بكلمات أخرى، في كل مرحلة من قراءة الكلمة، \textbf{يُمنع} أن يكون عدد حروف الـ $b$ التي قرأناها أكبر من عدد حروف الـ $a$ التي قرأناها. \\
أمثلة لكلمات موجودة في اللغة: $a, aaa, ababab, aabb$ \\
أمثلة لكلمات \textbf{غير} موجودة في اللغة: $b, ba, abba, baab, abb$.

الفكرة في الأوتومات الذي سيقبل هذه اللغة أنّنا في كل مرة نقرأ فيها $a$ سنضيف إلى الراصة الرمز $A$، وعند قراءة $b$ سنخرجه. \\
حتى نتأكد من تحقق الشرط: يُمنع أن نقرأ الحرف $b$ من المدخل عندما تكون الرّاصّة فارغة.

\begin{center}
\includegraphics[width=0.2\textwidth]{../../../images/PDAs/in_every_prefix_a_ge_b.png}
\end{center}
\clearpage
\subsubsection{عدد الـ $a$ مساوٍ لـ عدد الـ $b$}
في هذه اللغة، في كل مرة نقرأ فيها a: إذا كان أعلى الراصة هو الرمز A فإنّنا نضيف إلى الراصة الرمز A، أمّا إذا كان أعلى الراصة هو الرمز B فإنّنا نسحبه من أعلاها (حذفنا B مقابل A ). \\
بشكل مشابه: في كل مرة نقرأ فيها b: إذا كان أعلى الراصة هو الرمز B فإنّنا نضيف إلى الراصة الرمز B، أمّا إذا كان أعلى الراصة هو الرمز A فإنّنا نسحبه من أعلاها (حذفنا A مقابل B ).
\begin{center}
\includegraphics[width=0.6\textwidth]{../../../images/PDAs/a_equals_b.png}
\end{center}

% \subsubsection{عدد الـ $a$ أكبر أو يساوي عدد الـ $b$}
% هذا الشرط شبيه بالشرط الذي في المثال \ref{sssection:prefix}، غير أنّ هذا الشرط أكثر "تسامحًا"، فهو لا يشترط أن يكون الـ a أكبر من الـ b في كل بادئة، بل يكتفي بأن يتحقق الشرط في نهاية الكلمة. \\
% مثلًا: الكلمة $ba$ مقبولة في هذه اللغة، لكنّها مرفوضة في لغة المثال  \ref{sssection:prefix}.


% \section{مسائل متقدمة من ملفات الدورة}

% \subsection{مسألة 1: اللغة $L = \{ a^n b^m c^m d^n \mid n, m \ge 1 \}$}

% هذه اللغة تظهر بنية متداخلة (\textenglish{Nested Structure}).
% \begin{itemize}
%     \item $a$ في البداية يقابل $d$ في النهاية (الغلاف الخارجي).
%     \item $b$ في الوسط يقابل $c$ في الوسط (الغلاف الداخلي).
% \end{itemize}

% \subsubsection{استراتيجية الحل}
% بما أن الراصة تعمل بمبدأ \textenglish{LIFO} (الداخل آخراً خارج أولاً)، فهي تناسب هذا التركيب تماماً. الرموز التي تدخل أخيراً ($b$) هي التي يجب معالجتها أولاً (مع $c$).

% \begin{enumerate}
%     \item \textbf{معالجة $a$:} اقرأ $a$ وادفع رمزاً مميزاً (مثلاً $A$) في الراصة.
%     \item \textbf{معالجة $b$:} اقرأ $b$ وادفع رمزاً مميزاً آخر (مثلاً $B$) في الراصة.
%     \item \textbf{معالجة $c$:} الآن الراصة تحتوي $B$'s في الأعلى و $A$'s في الأسفل. اقرأ $c$ واسحب $B$. يجب أن ينتهي عدد الـ $c$ تماماً مع انتهاء الـ $B$'s.
%     \item \textbf{معالجة $d$:} بعد انتهاء $c$، ستصبح رموز $A$ مكشوفة في قمة الراصة. اقرأ $d$ واسحب $A$.
%     \item \textbf{القبول:} انتهاء الكلمة والراصة فارغة.
% \end{enumerate}

% \subsubsection{جدول الانتقالات (مبسط)}
% \begin{itemize}
%     \item $(q_0, a, S) \to (q_0, A S)$
%     \item $(q_0, a, A) \to (q_0, AA)$
%     \item $(q_0, b, A) \to (q_1, B A)$ \hfill (انتقال لقراءة $b$)
%     \item $(q_1, b, B) \to (q_1, BB)$
%     \item $(q_1, c, B) \to (q_2, \epsilon)$ \hfill (انتقال لقراءة $c$ والمطابقة)
%     \item $(q_2, c, B) \to (q_2, \epsilon)$
%     \item $(q_2, d, A) \to (q_3, \epsilon)$ \hfill (العودة لمطابقة $d$ مع $A$)
%     \item $(q_3, d, A) \to (q_3, \epsilon)$
%     \item $(q_3, \epsilon, S) \to (q_{acc}, S)$
% \end{itemize}

% \subsection{مسألة 3: $L = \{ a^2 b^k a^n \mid n < k \}$}
% وردت هذه المسألة في الملف \texttt{08-StackAutomata2.pptx}.
% الشروط:
% \begin{itemize}
%     \item تبدأ بـ $aa$.
%     \item يتبعها عدد $k$ من الـ $b$.
%     \item تنتهي بعدد $n$ من الـ $a$.
%     \item الشرط الأساسي: $n < k$ (عدد الـ $a$ في النهاية أقل تماماً من عدد الـ $b$ في الوسط).
% \end{itemize}

% \subsubsection{خوارزمية الحل من الشرائح}
% \begin{enumerate}
%     \item \textbf{قراءة $aa$:} اقرأ أول حرفين $a$ ولا تغير شيئاً جوهرياً في العد (فقط انتقل بين حالات للتأكد من وجودهما).
%     \item \textbf{أول $b$:} عند قراءة أول $b$، ادفع رمزاً خاصاً $S$ للراصة. هذا الرمز سيكون "علامة القاع" الخاصة بالعد.
%     \item \textbf{باقي الـ $b$'s:} لكل $b$ تالية، ادفع رمزاً عادياً $B$.
%     \item \textbf{قراءة الـ $a$'s الأخيرة:} لكل $a$ تقرؤها، اسحب $B$ من الراصة.
%     \item \textbf{شرط القبول ($n < k$):}
%     بما أن $n$ (عدد السحب) أقل من $k$ (عدد الدفع)، يجب أن تنتهي الكلمة (مدخلات $a$) وما زال في الراصة رموز $B$ أو الرمز $S$.
%     بمعنى آخر: \textbf{ممنوع} أن نصل لمرحلة نحاول فيها سحب $S$ ونحن ما زلنا نقرأ $a$. وأيضاً ممنوع أن تفرغ الراصة تماماً.
%     القبول يتم إذا انتهت الكلمة والراصة \textbf{ليست} فارغة (تحتوي $B$ أو $S$).
% \end{enumerate}

% \clearpage

% % =========================================================
% % الفصل السادس: اللا حتمية في PDA
% % =========================================================
% \section{اللا حتمية (\textenglish{Non-determinism})}
% \label{part:npda}

% \subsection{الفرق بين \textenglish{DPDA} و \textenglish{NPDA}}

% في الأوتومات النهائي، تعلمنا أن \textenglish{DFA} و \textenglish{NFA} متكافئان (لهما نفس القدرة التعبيرية).
% \textbf{ولكن في أوتومات الراصة، الأمر مختلف!}

% \begin{itemize}
%     \item \textbf{\textenglish{DPDA} (Deterministic PDA):}
%     أوتومات راصة ديتيرمنيستي (حتمي). لكل زوج (حالة، مدخل، قمة راصة) يوجد انتقال واحد كحد أقصى.
%     \item \textbf{\textenglish{NPDA} (Non-deterministic PDA):}
%     أوتومات راصة غير حتمي. يمكن أن يكون هناك عدة انتقالات ممكنة لنفس الوضع.
% \end{itemize}

% \begin{tcolorbox}[colback=red!10!white, title=حقيقة هامة]
% \textenglish{NPDA} أقوى من \textenglish{DPDA}. هناك لغات خالية السياق يمكن لـ \textenglish{NPDA} قبولها ولا يمكن لـ \textenglish{DPDA} قبولها.
% اللغات التي يقبلها \textenglish{DPDA} تسمى "اللغات خالية السياق الديتيرمنيستية" (\textenglish{DCFL}).
% \end{tcolorbox}

% \subsection{مثال على لغة تتطلب اللا حتمية}
% اللغة $L = \{ w w^R \mid w \in \{a,b\}^* \}$.
% هذه لغة التناظر (Palindromes) ذات الطول الزوجي، مثل $abba$ أو $baab$.
% المشكلة هنا: \textbf{أين هو المنتصف؟}
% عندما يقرأ الأوتومات الكلمة، لا يوجد علامة مميزة تخبره "الآن انتهى $w$ وبدأ $w^R$".

% \subsubsection{الحل باستخدام \textenglish{NPDA}}
% يقوم الأوتومات بـ "تخمين" المنتصف في كل خطوة.
% \begin{itemize}
%     \item في الحالة $q_0$، يوجد مساران:
%     \begin{enumerate}
%         \item قراءة الحرف ودفعه للراصة (افتراض أننا ما زلنا في النصف الأول).
%         \item الانتقال للحالة $q_1$ عبر $\epsilon$-transition (تخمين أننا وصلنا للمنتصف الآن) وبدء المطابقة.
%     \end{enumerate}
% \end{itemize}
% بما أن الأوتومات غير حتمي، إذا وجد مساراً واحداً ناجحاً (تخمين صحيح للمنتصف) يؤدي لقبول الكلمة، فإن الكلمة مقبولة.

% \clearpage

% % =========================================================
% % الفصل السابع: اللغات خالية السياق (CFL)
% % =========================================================
% \section{اللغات خالية السياق وخصائصها}
% \label{part:cfl}

% اللغات التي يتعرف عليها أوتومات الراصة تسمى \textbf{اللغات خالية السياق} (\textenglish{Context-Free Languages}).

% \subsection{هرمية تشومسكي (\textenglish{Chomsky Hierarchy})}
% تقع هذه اللغات في المستوى الثاني من الهرمية:
% \begin{enumerate}
%     \item اللغات المنتظمة (\textenglish{Regular}) - يتعرف عليها \textenglish{FA}.
%     \item \textbf{اللغات خالية السياق (\textenglish{CFL})} - يتعرف عليها \textenglish{PDA}.
%     \item اللغات حساسة السياق (\textenglish{CSL}) - يتعرف عليها \textenglish{Linear Bounded Automata}.
%     \item اللغات القابلة للعد ريكيرسيفياً (\textenglish{R.E.}) - يتعرف عليها \textenglish{Turing Machine}.
% \end{enumerate}

% \subsection{خصائص الانغلاق (\textenglish{Closure Properties})}
% بناءً على الملف \texttt{07-ContextFreeLanguages.pptx}:

% اللغات خالية السياق \textbf{مغلقة} تحت العمليات التالية:
% \begin{itemize}
%     \item \textbf{الاتحاد ($\cup$):} اتحاد لغتين \textenglish{CFL} هو \textenglish{CFL}.
%     \item \textbf{الربط/الإلصاق ($\cdot$):} إلصاق لغتين \textenglish{CFL} هو \textenglish{CFL}.
%     \item \textbf{نجمة كلين ($^*$):} تكرار لغة \textenglish{CFL} هو \textenglish{CFL}.
% \end{itemize}

% ولكنها \textbf{غير مغلقة} تحت:
% \begin{itemize}
%     \item \textbf{التقاطع ($\cap$):} تقاطع لغتين \textenglish{CFL} ليس بالضرورة \textenglish{CFL}.
%     مثال: $L_1 = \{a^n b^n c^m\}$ و $L_2 = \{a^m b^n c^n\}$. كلاهما \textenglish{CFL}. تقاطعهما هو $\{a^n b^n c^n\}$ وهي لغة غير خالية السياق.
%     \item \textbf{المتممة (\textenglish{Complement}):} متممة لغة \textenglish{CFL} ليست بالضرورة \textenglish{CFL}.
% \end{itemize}

% \subsection{لغات ليست خالية السياق}
% أشهر مثال للغة لا يستطيع \textenglish{PDA} حلها هو $L = \{ a^n b^n c^n \}$.
% \textbf{السبب:} الراصة تمكننا من مقارنة كميتين فقط في آن واحد (ما في الراصة مقابل ما في الدخل). بمجرد تفريغ الراصة لمقارنة $b$ مع $a$، نفقد المعلومات اللازمة لمقارنة $c$. لحل هذه المشكلة نحتاج إلى راصتين (وهو ما يعادل آلة تيورنج).

\end{document}
